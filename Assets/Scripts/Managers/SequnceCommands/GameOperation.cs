using Cysharp.Threading.Tasks;
using System;
using System.Collections.Generic;
using System.Linq;
using Zenject;

public abstract class GameOperation : IExecutableTask {
    [Inject] protected readonly IVisualManager visualManager;
    [Inject] protected readonly IVisualTaskFactory visualTaskFactory;

    protected TargetRegistry targetRegistry = new();

    private readonly Dictionary<string, object> filledTargets = new();
    private readonly List<TargetInfo> targetInfos = new();

    protected GameOperation(UnitModel source) {
        Source = source;
    }

    public bool IsMandatory { get; set; }
    public UnitModel Source { get; private set; }

    public abstract UniTask<bool> Execute();

    protected void AddTarget(TargetInfo targetInfo) {
        targetInfos.Add(targetInfo);
    }

    protected bool TryGetTypedTarget<T>(string key, out T result) {
        if (filledTargets.TryGetValue(key, out var unit) && unit is T casted) {
            result = casted;
            return true;
        }

        result = default;
        return false;
    }

    public void SetTarget(string key, object target) {
        if (!filledTargets.TryGetValue(key, out var targetBase)) {
            filledTargets[key] = target;
        } else {
            throw new Exception($"Target already set");
        }
    }

    public void SetTargets(IReadOnlyDictionary<string, object> filledTargets) {
        foreach (var kvp in filledTargets) {
            SetTarget(kvp.Key, kvp.Value);
        }
    }

    public bool IsReady() => !HaveUnfilledTargets();

    public bool HaveUnfilledTargets() {
        return filledTargets.Count != targetInfos.Count;
    }

    public void SetSource(UnitModel source) {
        Source = source;
    }

    public IEnumerable<string> GetTargetKeys() => filledTargets.Keys;
    public List<TargetInfo> GetTargets() => targetInfos.ToList();
}




public class TargetInfo {
   
    public string Key { get; }
    public object Unit { get; private set; }

    public ITargetRequirement Requirement { get; }
    public ITargetInstruction Instruction { get; }

    public bool HasTarget => Unit != null;

    public TargetInfo(string key, ITargetRequirement requirement, ITargetInstruction instruction = null) {
        Key = key;
        Requirement = requirement;
        Instruction = instruction ?? new AutoGeneratedInstruction(requirement);
    }

    public void SetTarget(object target) {
        Unit = target;
    }

    public object GetTarget() => Unit;

    public ValidationResult IsValid(object value = null, ValidationContext context = null) {
        return Requirement.IsValid(value, context);
    }

    public TargetSelector GetTargetSelector() {
        return Requirement.RequiredSelector;
    }

    public string GetInstruction(InstructionContext context = null) {
        context ??= new InstructionContext(Requirement);
        return Instruction.GetInstruction(context);
    }

    public string GetShortHint(InstructionContext context = null) {
        context ??= new InstructionContext(Requirement);
        return Instruction.GetShortHint(context);
    }

    public string GetDetailedHelp(InstructionContext context = null) {
        context ??= new InstructionContext(Requirement);
        return Instruction.GetDetailedHelp(context);
    }
}

public class TargetRegistry {
    private readonly Dictionary<string, object> _targets = new();

    public void Add(string key, object target) {
        if (string.IsNullOrEmpty(key))
            throw new ArgumentException("Key cannot be null or empty", nameof(key));

        _targets[key] = target;
    }

    public bool TryGet<T>(string key, out T result) {
        if (_targets.TryGetValue(key, out var value) && value is T casted) {
            result = casted;
            return true;
        }

        result = default;
        return false;
    }

    public T Get<T>(string key) {
        if (!_targets.TryGetValue(key, out var value))
            throw new KeyNotFoundException($"Target with key '{key}' not found");

        return (T)value;
    }
}


public readonly struct TargetKey {
    public string Value { get; }
    private TargetKey(string value) => Value = value;

    public static readonly TargetKey MainTarget = new("MainTarget");
    public static readonly TargetKey SecondaryTarget = new("SecondaryTarget");

    public override string ToString() => Value;
    public override bool Equals(object? obj) =>
    obj is TargetKey other && Value == other.Value;

    public override int GetHashCode() => Value.GetHashCode();

    public static bool operator ==(TargetKey left, TargetKey right) => left.Equals(right);
    public static bool operator !=(TargetKey left, TargetKey right) => !left.Equals(right);
}
